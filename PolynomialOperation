/******************************************************************************
Program in C for the following operation son Singly
Circular Linked List (SCLL) with header nodes
a. Represent and Evaluate a Polynomial P(x,y,z)=6x2y2z-4yz5+3x3yz+2xy5z-2xyz3
b. Find the sum of two polynomials POLY1(x,y,z)and POLY2(x,y,z)and store theresult in POLYSUM(x,y,z)
   Support the program with appropriate functions for each of the above operations

******************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <math.h>

// Node structure for a term in the polynomial
struct PolyTerm {
	int coefficient;             // Coefficient of the polynomial term
	int pow_x;                   // Power of x in the term
	int pow_y;                   // Power of y in the term
	int pow_z;                   // Power of z in the term
	struct PolyTerm* next;       // Pointer to the next term in the circular linked list
};

typedef struct PolyTerm* POLYPTR;  // Define POLYPTR as a pointer to struct PolyTerm

// Function to insert a term in the polynomial (inserting at end of circular list)
POLYPTR fnInsertTerm(POLYPTR poly, int coef, int pow_x, int pow_y, int pow_z) {
	POLYPTR cur;
	// Allocate memory for the new node and set its data fields
	POLYPTR newNode = (POLYPTR)malloc(sizeof(struct PolyTerm));
	newNode->coefficient = coef;
	newNode->pow_x = pow_x;
	newNode->pow_y = pow_y;
	newNode->pow_z = pow_z;
	newNode->next = NULL;

	cur = poly;
	// Traverse the list to find the last node
	while (cur->next != poly) {
		cur = cur->next;
	}
	// Insert new node at the end and link it back to the head node
	cur->next = newNode;
	newNode->next = poly;
	return poly;
}

// Function to display the polynomial in readable form
void fnDispPolynomial(POLYPTR poly) {
	if (poly->next == poly) {  // Check if the polynomial is empty
		printf("Polynomial is empty.\n");
		return;
	}
	POLYPTR cur = poly->next;  // Start from the first term
	do {
		// Print each term in the format: coefficient * x^pow_x * y^pow_y * z^pow_z
		printf("%dx^%dy^%dz^%d", cur->coefficient, cur->pow_x, cur->pow_y, cur->pow_z);
		cur = cur->next;
		if (cur != poly) {  // Print '+' between terms, except for the last term
			if (cur->coefficient > 0)
				printf("+");
		}
	} while (cur != poly);
	printf("\n");
}

// Function to evaluate the polynomial for given values of x, y, and z
int fnEvaluatePolynomial(POLYPTR poly, int x, int y, int z) {
	int result = 0;
	if (poly->next == poly) {  // Check if the polynomial is empty
		return result;
	}
	POLYPTR cur = poly->next;
	do {
		int termValue = cur->coefficient;  // Start with the term's coefficient
		// Evaluate term value by raising x, y, and z to their respective powers
		termValue *= pow(x, cur->pow_x);
		termValue *= pow(y, cur->pow_y);
		termValue *= pow(z, cur->pow_z);
		result += termValue;  // Accumulate the evaluated term value in result
		cur = cur->next;
	} while (cur != poly);
	return result;  // Return the computed result of the polynomial
}

// Function to check if two terms have the same powers of x, y, and z
bool fnMatchTerm(POLYPTR p1, POLYPTR p2) {
	bool bMatches = true;  // Assume terms match until proven otherwise
	if (p1->pow_x != p2->pow_x) bMatches = false;
	if (p1->pow_y != p2->pow_y) bMatches = false;
	if (p1->pow_z != p2->pow_z) bMatches = false;
	return bMatches;  // Return true if terms match in all powers, false otherwise
}

// Function to add two polynomials (poly1 and poly2) and store the result in polySum
POLYPTR fnAddPolynomials(POLYPTR poly1, POLYPTR poly2, POLYPTR polySum) {
	POLYPTR cur1 = poly1->next;  // Start from the first term of poly1
	POLYPTR cur2 = poly2->next;  // Start from the first term of poly2

	// Insert each term of poly1 into polySum
	do {
		polySum = fnInsertTerm(polySum, cur1->coefficient, cur1->pow_x, cur1->pow_y, cur1->pow_z);
		cur1 = cur1->next;
	} while (cur1 != poly1);

	// Add terms of poly2 to polySum, combining like terms
	do {
		cur1 = polySum->next;  // Start from the first term in polySum
		bool bMatchFound = false;
		do {
			// Check if there is a term in polySum that matches the current term of poly2
			if (fnMatchTerm(cur1, cur2)) {
				cur1->coefficient += cur2->coefficient;  // Combine like terms by adding coefficients
				bMatchFound = true;
				break;
			}
			cur1 = cur1->next;
		} while (cur1 != polySum);

		// If no match found, insert the current term of poly2 as a new term in polySum
		if (!bMatchFound) {
			polySum = fnInsertTerm(polySum, cur2->coefficient, cur2->pow_x, cur2->pow_y, cur2->pow_z);
		}
		cur2 = cur2->next;
	} while (cur2 != poly2);

	return polySum;  // Return the result polynomial
}

int main() {
	// Initialize the polynomials with header nodes pointing to themselves (empty circular linked lists)
	POLYPTR poly1 = (POLYPTR)malloc(sizeof(struct PolyTerm));
	poly1->next = poly1;
	POLYPTR poly2 = (POLYPTR)malloc(sizeof(struct PolyTerm));
	poly2->next = poly2;
	POLYPTR polySum = (POLYPTR)malloc(sizeof(struct PolyTerm));
	polySum->next = polySum;

	// Define POLY1(x, y, z) = 6x^2y^2z - 4yz^5 + 3x^3yz + 2xy^5z - 2xyz^3
	poly1 = fnInsertTerm(poly1, 6, 2, 2, 1);
	poly1 = fnInsertTerm(poly1, -4, 0, 1, 5);
	poly1 = fnInsertTerm(poly1, 3, 3, 1, 1);
	poly1 = fnInsertTerm(poly1, 2, 1, 5, 1);
	poly1 = fnInsertTerm(poly1, -2, 1, 1, 3);

	// Display POLY1
	printf("POLY1(x, y, z) = ");
	fnDispPolynomial(poly1);

	// Define POLY2(x, y, z) = xyz + 4x^3yz (example terms)
	poly2 = fnInsertTerm(poly2, 1, 1, 1, 1);
	poly2 = fnInsertTerm(poly2, 4, 3, 1, 1);

	// Display POLY2
	printf("POLY2(x, y, z) = ");
	fnDispPolynomial(poly2);

	// Add POLY1 and POLY2, storing the result in POLYSUM
	polySum = fnAddPolynomials(poly1, poly2, polySum);

	// Display POLYSUM (the result of addition)
	printf("\nPOLYSUM(x, y, z) = ");
	fnDispPolynomial(polySum);

	// Evaluate POLYSUM for specific values of x, y, and z (e.g., x = 1, y = 1, z = 1)
	int x = 1, y = 1, z = 1;
	int iRes = fnEvaluatePolynomial(poly1, x, y, z);
	printf("\nResult of POLYSUM(%d, %d, %d): %d\n", x, y, z, iRes);

	return 0;
}

/**********************************************************
Explanation of the Functions and Key Parts:
Structure Definition (struct PolyTerm):

Defines the fields for a polynomial term (coefficient, pow_x, pow_y, pow_z).
Each node has a next pointer to link to the next term in a circular linked list.
fnInsertTerm:

Inserts a new term into the polynomial represented by a circular linked list.
Finds the last node, inserts the new term at the end, and links it back to the head.
fnDispPolynomial:

Displays the polynomial in a readable format.
Traverses the circular linked list and prints each term with the correct format.
fnEvaluatePolynomial:

Evaluates the polynomial for given values of x, y, and z.
Computes each termbs value by raising
*********************************************************/
